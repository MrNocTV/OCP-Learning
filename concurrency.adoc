:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 3
:source-highlighter: highlightjs
:icons: fontt
:imagesdir: images
:sectnums:

== Thread

- A thread is a smallest unit of execution that can be scheduled by the operating system.

- A process is a group of associated threads that can execute in the same, shared environment. single-thread prrocess and multi-thread process.

- A task is a single unit of work performed by a thread.

image::process_model.png[]

== Thread type

- System thread: created by JVM and runs in the background. Ex: garbage collection thread

- User defined thread: created by the developer to accomplish some task. 

- A daemon thread will not prevent the JVM from exiting when program finishes. -> A Java application terminates when the only threads that are running are daemon threads.

- Ex: If the only thread running is garbage collection thread, the JVM will automatically shutdown. Both user-defined and system threads can be marked as daemon threads.

== Understand thread concurrency

- When a thread allotted time is complete but the thread has not finished processing, a context switch occur.

- A context switch  is the process of storing a thread's current state and later restoring the state of the thread to continue execution.

- Be default, a user thread has a Thread.NORM_PROPRITY value.

- If two threads have the same priority, the thread schedular will arbitrarily choose the one to process first in most situation.

== Runable

[source,java]
----
@FunctionalInterface public interface Runnable {
    void run();
}
----

== Creating a Thread

- There are two ways to create a Thread, 

* provide a `Runable` object or lambda expression to the `Thread` constructor.

* extends Thread class and override the `run()` method.

[source,java]
----
public class PrintData implements Runnable {
    public void run() {
        for (int i = 0; i < 3; i++)
            System.out.println("Printing record: "+i);
    }

    public static void main(String[] args) {
        (new Thread(new PrinData())).start();
    }
}

public class ReadInventoryThread extends Thread {
    public void run() {
        System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
        (new ReadInventoryThread()).start();
    }
}
----

- While the following code snippet will compile, none will actually execute a task on a separate processing thread.

[source,java]
----
new PrintData().run();
(new Thread(new PrintData())).run();
----

== Thread vs Runnable

- If you need to define your own Thread rules upon which multipel tasks will rely, such as priority Thread, extending Thread maybe preferable.

- Implementing `Runnable` is often a better object-oriented design practice since it separates the task being performed from the Thread object performing it.

- Implementing `Runnable` allows the class to be used by numerous Concurrency API classes.

== Polling with sleep

- Polling is the process of intermittently checking data at some fixed interval.

== Creating Thread with ExecutorService

[source,java]
----
import java.util.concurrent.*;
public class ZooInfo {
    public static void main(String[] args) {
        ExecutorService service = null;
        try {
            service = Executors.newSingleThreadExecutor();
            System.out.println("begin");
            service.execute(() -> System.out.println("Printing zoo inventory"));
            service.execute(() -> {for(int i=0; i<3; i++)
                System.out.println("Printing record: "+i);}
            );
            service.execute(() -> System.out.println("Printing zoo inventory"));
            System.out.println("end");
        } finally {
            if(service != null) service.shutdown();
        }
    }
}
----

- With a single-thread executor, results are guaranteed to be executed in the order in which they are added to the executor service.

- Once you have finished using a thread executor, it is important that you call the `shutdown()` method. A thread executor creates a non-daemon thread on the first task that is executed, so failing to call `shutdown()` will result in your application never terminating.

- `shutdown()` will reject any new tasks submitted to the thread executor while continuing to execute any previously sumitted tasks.

- If a new task is submitted to the thread executor while it is shutting down, a RejectedExecutionException will be thrown.

image::executor-service-life-cycle.png[]

- `List<Runnable> shutdownNow()` attempts to stop all running tasks and discards any that have not been started yet. It returns a list List<Runnable> of tasks that were never started.

== Submitting Tasks

- `void execute(Runnable r)`
- `Future<?> submit(Runnable r)`
- `<T> Future<T> submit(Callable<T> task)`: 
- `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException`: execute the given tasks, synchronously return the result of all tasks, in the same order with `Collection<? extends Callable<T>>`
- `<T> T invokeAny( Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException`: execute the given tasks, synchronously return the result of one of finished tasks, cancelling any unfinished tasks.

- With `invokeAll()`, even though Future.isDone() returns true for each
element in the returned List , a task could have completed normally or thrown an exception.

- With `invokeAny()`, while the first task to finish is often returned, this behavior is not guaranteed, as any completed task can be returned by this method.

- We can set timeout for `invokeAll()` and `invokeAny()`.

== Wating for results

[source, java]
----
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));
----

image::future-methods.png[]

[source,java]
----
import java.util.concurrent.*;
public class CheckResults {
    private static int counter = 0;
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService service = null;

        try {

        } catch (TimeoutException e) {
            service = Executors.newSingleThreadExecutor();
            Future<?> result = service.submit(() -> {
                for (int i = 0; i < 500; i++) CheckResults.counter++;
            });

            result.get(10, TimeUnit.SECONDS);
            System.out.println("Reached!")
        } finally {
            if (service != null) service.shutdown();
        }
    }
}
----

== Introducing Callable

[source,java]
----
@FunctionalInterface public interface Callable<V> {
    V call() throws Exception;
}
----

=== Ambiguous lambda expression
- Since both `Callable` and `Supplier` are functional interface, with 1 method that take no arguments and return a value. It's impossible for Java to know which one you want to use if there are two methods, 1 take Callable and 1 take Supplier

[source,java]
----
public class AmbiguousLambdaSample {
    public static void useCallable(Callable<Integer> expression) {}
    public static void useSupplier(Supplier<Integer> expression) {}
    public static void use(Supplier<Integer> expression) {}
    public static void use(Callable<Integer> expression) {}
    
    public static void main(String[] args) {
        useCallable(() -> {throw new IOException();}); //COMPILES
        useSupplier(() -> {throw new IOException();}); // DOES NOT COMPILE
        use(() -> {throw new IOException();}); // DOES NOT COMPILE
    }
}
----

- The second line of the main() method does not compile, as Supplier does not support check exception.

- The last line in main method(), the compiler does not take into account that an exception is thrown in the body of use(), it does not know which `use()` should be used.

- However, if you cast lambda expression, it will compile

[source,java]
----
use((Callable<Integer>) () -> {throw new IOException("");}); //COMPILES
----

=== Example with Callable

- `Future<?>` will always return `null` when calling `get()` if you `submit` a Runnable.

[source,java]
----
import java.util.concurrent.*;

public class AddData {
    public static void main(String[] args) throws InterruptedException, ExecutionException{
        ExecutorService service = null;
        try {
            service = Executors.newSingleThreadExecutor();
            Future<Integer> result = service.submit(() -> 30 + 11);
            System.out.println(result.get());
        } finally {
            if (service != null) service.shutdown();
        }
    }
}
----

- `Runnable` and `Callable` are interchangable where the lambda does not throw an exception and there is no return type.

=== Checked exception in Runnable and Callable

[source,java]
----
service.submit(() -> {Thread.sleep(1000); return null;}) // COMPILES, because Java uses Callable
service.submit(() -> {Thread.sleep(1000);}); //DOES NOT COMPILE, because Java use Runnable
----

WARNING: If the @FunctionalInterface throws checked exception, the caller might not need to use it in a try/catch block or redeclare the exception in throws.

=== Waiting for all tasks to be finished

- using `awaitTermination(long time, TimeUnit unit)`, this method waits until all tasks are finished, or throw InterruptedException.

[source,java]
----
ExecutorService service = null;

try {
    service = Executors.newSingleThreadExecutor();
    // add tasks to executor
} finally {
    if (service != null) service.shutdown();
}

if (service != null) {
    service.awaitTermination(1, TimeUnit.MINUTES);
    if (service.isTerminated())
        System.out.println("All tasks finished");
    else
        System.out.println("At least one task is still running");
}
----

== Scheduling Tasks

[source,java]
----
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
----

image::scheduled-executor-service-methods.png[]

- The first two methods return a `ScheduledFuture<V>` instance.

[source,java]
----
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";

Future<?> result1 = service.schedule(task1, 10, TimeUnit.SECONDS);
Future<?> result2 = service.schedule(task2, 8, TimeUnit.MINUTES);
----

- If the `ScheduledExecutorService` is shutdown by the time the scheduled task execution time is reached, they will be discarded.

- `scheduleAtFixedRate()` is the closest built-in Java equivalent to Cron job in Linux.

== Increasing concurrency with pools.

image::executors-methods.png[]

- Get the number of CPUs available:
[source,java]
----
Runtime.getRuntime().availableProcessors();
----

== Synchronizing Data Access

=== Processing Data with Atomic Classes

image::atomic-classes.png[]

image::common-atomic-methods.png[]

== Improving access with Synchronized block

- A monitor is a structure that supports mutual exclusion or the property that at most one thread is executing a particular segment of code at a given time.

- In Java, any Object can be used as a monitor, along with synchronzied keyword.

[source,java]
----
SheepManager manager = new SheepManager();

synchronized(manager) {
    // 
}
----

- This code below prints 1 to 10.

[source,java]
----
import java.util.concurrent.*;
public class SheepManager {
    private int sheepCount = 0;
    private void incrementAndReport() {
        synchronized(this) {
            System.out.print((++sheepCount)+" ");
        }
    }
    public static void main(String[] args) {
        ExecutorService service = null;

        try {
            service = Executors.newFixedThreadPool(20);
            SheepManager manager = new SheepManager();
            for(int i=0; i<10; i++)
            service.submit(() -> manager.incrementAndReport());
        } finally {
            if(service != null) service.shutdown();
        }
    }
}
----

- Synchronization is about  protecting data integerity  at the cost of performance.

== Concurrent Collections

[source,java]
----
private Map<String, Object> test = new ConcurrentHashMap<>();

public void put(String key, String value) {
    test.put(key, value);
}

public Object get(String key) {
    return test.get(key);
}
----

=== Understanding memory consistency errors

- The purpose of concurrent collection classes is to solve common memory consistency errors. A memory consistency error occurs when two threads have inconsistent views of what should be the same data.

- When two threads try to modify the same non-concurrent collection, the JVM may throw a ConcurrentModificationException at run time.
[source,java]
----
Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet())
    foodData.remove(key); // ConcurrentModificationException
----
=> it is due to keySet is not properly updated after the first element is removed

However, when we change to `ConcurrentHashMap`

[source,java]
----
Map<String, Object> foodData = new ConcurrentHashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet())
    foodData.remove(key);
----
=> the iterator created by keySet is updated as soon as an object is removed from the Map.

=== Working with Concurrent Classes

image::concurrent-collection-classes.png[]

[source,java]
----
Map<String,Integer> map = new ConcurrentHashMap<>();
map.put("zebra", 52);
map.put("elephent", 10);
System.out.println(map.get("elephent"));

Queue<Integer> queue = new ConcurrentLinkedQueue<>();
queue.offer(31);
System.out.println(queue.peek());
System.out.println(queue.poll());

Deque<Integer> deque = new ConcurrentLinkedDeque<>();
deque.offer(1);
deque.push(4);
System.out.println(deque.peek());
System.out.println(deque.pop());
----

=== Blocking Queues

- The `BlockingQueue` is just like a regular `Queue`, except that it includes methods that will wait a specific amount of time to complete an operation.

- `offer(E e, long timeout, TimeUnit unit)`: return `false` if time elapses before space is available.
- `poll(long timeout, TimeUnit unit)`: return `null` if the time elapses before the item is available.

[source,java]
----
try {
    BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
    blockingQueue.offer(39);
    blockingQueue.offer(3, 4, TimeUnit.SECONDS);
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll(10, TimeUnit.MILLISECONDS));
} catch (InterruptedException e) {
    // Handle interruption
}
----

- The `LinkedBlockingDeque` methods

* `offerFirst(E e, long timeout, TimeUnit unit)`: return `false` if time elapses before space is available
* `offerLast(E e, long timeout, TimeUnit unit)`: return `false` if time elapses before space is available
* `pollFirst(long timeout, TimeUnit unit)`: return `null` if time elapses before space is available
* `pollLast(long timeout, TimeUnit unit)`: return `null` if time elapses before space is available.

[source,java]
----
try {
    BlockingDeque<Integer> blockingDeque = new LinkedBlockingDeque<>();
    blockingDeque.offer(91);
    blockingDeque.offerFirst(5, 2, TimeUnit.MINUTES);
    blockingDeque.offerLast(47, 100, TimeUnit.MICROSECONDS);
    blockingDeque.offer(3, 4, TimeUnit.SECONDS);
    System.out.println(blockingDeque.poll());
    System.out.println(blockingDeque.poll(950, TimeUnit.MILLISECONDS));
    System.out.println(blockingDeque.pollFirst(200, TimeUnit.NANOSECONDS));
    System.out.println(blockingDeque.pollLast(1, TimeUnit.SECONDS));
} catch (InterruptedException e) {
    // Handle interruption
}
----

=== SkipList Collections

- `ConcurrentSkipListSet` and `ConcurrentSkipListMap` are concurrent versions of their sorted counterparts, `TreeSet` and `TreeMap` respectively.

=== CopyOnWrite Collections

- `CopyOnWriteArrayList` and `CopyOnWriteArraySet`, these classes copy all of their elements to a new underlying structure anytime an element is added, modified, or removed. By a modified element, we mean that the
reference in the collection is changed. Modifying the actual contents of the collection will not cause a new structure to be allocated.

[source,java]
----
List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(4,3,52));
for(Integer item: list) {
    System.out.print(item+" ");
    list.add(9);
}
System.out.println();
System.out.println("Size: "+list.size());
----

Output
----
4 3 52
Size: 6
----

=== Optaining Synchronized Collections

image::synchronized-collections-method.png[]

WARNING: while the methods synchronize access to data elements, such as `get()` and `set()` methods, they do not synchronize access on any iterators that you may create from the synchronized collections. You must use a synchronized block if you need to iterate over any returned collections

[source,java]
----
List<Integer> list = Collections.synchronizedList(Arrays.asList(1,2,3));
synchronized(list) {
    for (int data : list)
        System.out.print(data + " ");
}
----

WARNING: unlike concurrent collections, the synchronized collections throw an exception if they are modified within an iterator by a single thread.

[source,java]
----
Map<String, Object> foodData = new HashMap<>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
Map<String, Object> synchronizedFoodData = Collections.synchronizedMap(foodData);
for (String key : synchronizedFoodData.keySet())
    synchronizedFoodData.remove(key);// THROW ConcurrentModificationException
----

== Parallel Streams

- By default, the number of threads available in a parallel stream is related to the number of available CPUs in your environment.

=== Creating Parallel Streams

- `parallel()`: create a parallel stream from an existing stream

[source,java]
----
Stream<Integer> stream = Arrays.asList(1,2,3,4,5,6).stream();
Stream<Integer> parallelStream = stream.parallel();
----

- `parallelStrem()`: create a Stream from a Java Collection class

[source,java]
----
Stream<Integer> parallelStream2 = Arrays.asList(1,2,3,4,5,6).parallelStream();
----

NOTE: The Stream interface includes a method `isParallel()` that can be used
to test if the instance of a stream supports parallel processing. Some
operations on streams preserve the parallel attribute, while others do
not. For example, the `Stream.concat(Stream s1, Stream s2)` is parallel
if either s1 or s2 is parallel. On the other hand, `flatMap()` creates a new
stream that is not parallel by default, regardless of whether the underlying
elements were parallel.

=== Processing tasks in parallel

[source,java]
----
Arrays.asList(1,2,3,4,5,6)
    .parallelStream()
    .forEach(s -> System.out.print(s+" "));
----

- The output of the above code is unpredictable, however you can use `forEachOrdered()` to force a parallel stream to process the results in order at the cost of performance.

[source,java]
----
Arrays.asList(1,2,3,4,5,6)
    .parallelStream()
    .forEachOrdered(s -> System.out.print(s+" "));
----

=== Understanding performance improvements

[source,java]
----
import java.util.*;
public class WhaleDataCalculator {
    public int processRecord(int input) {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            // Handle interrupted exception
        }
        return input+1;
    }

    public void processAllData(List<Integer> data) {
        data.stream().map(a -> processRecord(a)).count();
    }

    public static void main(String[] args) {
        WhaleDataCalculator calculator = new WhaleDataCalculator();
        // Define the data
        List<Integer> data = new ArrayList<Integer>();
        for(int i=0; i<4000; i++) data.add(i);
        // Process the data
        long start = System.currentTimeMillis();
        calculator.processAllData(data);
        double time = (System.currentTimeMillis()—start)/1000.0;
        // Report results
        System.out.println("\nTasks completed in: "+time+" seconds");
        // Tasks completed in: 40.044 seconds
    }
}
----

If we change it to parallelStream, the tasks completed in about 10 seconds

[source,java]
----
   public void processAllData(List<Integer> data) {
        data.parallelStream().map(a -> processRecord(a)).count();
    }
----

=== Avoiding Stateful Operations

[source,java]
----
List<Integer> data = Collections.synchronizedList(new ArrayList<>());
Arrays.asList(1,2,3,4,5,6).parallelStream()
    .map(i -> {data.add(i); return i;}) // AVOID STATEFUL LAMBDA EXPRESSIONS!
    .forEachOrdered(i -> System.out.print(i+" "));

System.out.println();
for(Integer e: data) {
    System.out.print(e+" ");
}
----
The following is a sample generation of this code snippet using a parallel stream:
----
1 2 3 4 5 6
2 4 3 5 6 1
----
- Anytime you are working with a Collection with a parallel stream, it is recommended that you use a concurrent collection. For example, for an `ArrayList` object, the JVM internally manages a primitive array of the same type. As the size of the dynamic `ArrayList` grows, a new, larger primitive array is periodically required. If two threads both trigger the array to be resized at the same time, a result can be lost, producing the unexpected value.

=== Performing order-based tasks

Since order is not guaranteed with parallel streams, methods such as findAny() on parallel streams may result in unexpected behavior

[source,java]
----
System.out.print(Arrays.asList(1,2,3,4,5,6).stream().findAny().get()); // 1

System.out.print(Arrays.asList(1,2,3,4,5,6).parallelStream().findAny().get()); // unpredictable
----

the results of ordered operations on a parallel stream will be consistent
with a serial stream, calling `skip(5).limit(2).findFirst()` will return the
same result on ordered serial and parallel streams.



=== Unordered stream

- Create an unorder stream

[source,java]
----
Arrays.asList(1,2,3,4,5,6).stream().unordered();
----

This method does not actually reorder the elements; it just tells the JVM that if an
order-based stream operation is applied, the order can be ignored. For example, calling `skip(5)` on an unordered stream will skip any 5 elements, not the first 5 required on an ordered stream.

For serial streams, using an unordered version has no effect, but on parallel streams, the results can greatly improve performance:
[source,java]
----
Arrays.asList(1,2,3,4,5,6).stream().unordered().parallel();
----

=== Combining result with `reduce()`

[source,java]
----
System.out.println(Arrays.asList('w', 'o', 'l', 'f')
    .stream()
    .reduce("",(c,s1) -> c + s1,
        (s2,s3) -> s2 + s3));
----

[source,java]
----
System.out.println(Arrays.asList(1,2,3,4,5,6)
    .parallelStream()
    .reduce(0,(a,b) -> (a-b))); // NOT AN ASSOCIATIVE ACCUMULATOR
    // resutl is unpredictable
----

[source,java]
----
System.out.println(Arrays.asList("w","o","l","f")
    .parallelStream()
    .reduce("X",String::concat));
In fact, it can output XwXoXlXf . As part of the parallel process, the identity is applied to
multiple elements in the stream, resulting in very unexpected data.
----

=== Combining result with `collect()`

Like `reduce()`, the Streams API includes a three-argument version of `collect()` that takes accumulator and combiner operators, along with a supplier operator instead of an identity.

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
SortedSet<String> set = stream.collect(ConcurrentSkipListSet::new, Set::add, Set::addAll);
System.out.println(set); // [f, l, o, w]
----

[source,java]
----
Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
----

Requirements for Parallel Reduction with collect()

- The stream is parallel.
- The parameter of the collect operation has the Collector.Characteristics.CONCURRENT
characteristic.
- Either the stream is unordered, or the collector has the characteristic
Collector.Characteristics.UNORDERED .

[source,java]
----
Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, String> map = ohMy
    .collect(Collectors.toConcurrentMap(String::length, k -> k,
    (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // java.util.concurrent.ConcurrentHashMap

----

The Collectors class includes two sets of methods for retrieving collectors
that are both UNORDERED and CONCURRENT , `Collectors.toConcurrentMap()` and
`Collectors.groupingByConcurrent()`, and therefore it is capable of performing parallel
reductions efficiently

[source,java]
----
Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingByConcurrent(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
----

== Managing Concurrent Processes

=== CyclicBarrier

The CyclicBarrier class allows us to perform complex, multi-threaded tasks, while all
threads stop and wait at logical barriers.

[source,java]
----
import java.util.concurrent.*;
public class LionPenManager {
    private void removeAnimals() { System.out.println("Removing animals"); }
    private void cleanPen() { System.out.println("Cleaning the pen"); }
    private void addAnimals() { System.out.println("Adding animals"); }
    public void performTask(CyclicBarrier c1, CyclicBarrier c2) {
        try {
            removeAnimals();
            c1.await();
            cleanPen();
            c2.await();
            addAnimals();
        } catch (InterruptedException | BrokenBarrierException e) {
            // Handle checked exceptions here
        }
    }
    public static void main(String[] args) {
        ExecutorService service = null;
        try {
            service = Executors.newFixedThreadPool(4);
            LionPenManager manager = new LionPenManager();
            CyclicBarrier c1 = new CyclicBarrier(4);
            CyclicBarrier c2 = new CyclicBarrier(4,
            () -> System.out.println("*** Pen Cleaned!"));
            for(int i=0; i<4; i++)
                service.submit(() -> manager.performTask(c1,c2));
        } finally {
            if(service != null) service.shutdown();
        }
    }
}
----

The following is sample output based on this revised implementation of our
LionPenManager class:
----
Removing animals
Removing animals
Removing animals
Removing animals
Cleaning the pen
Cleaning the pen
Cleaning the pen
Cleaning the pen
*** Pen Cleaned!
Adding animals
Adding animals
Adding animals
Adding animals
----

NOTE: After a CyclicBarrier is broken, all threads are released and the number of threads wait-
ing on the CyclicBarrier goes back to zero. At this point, the CyclicBarrier may be
used again for a new set of waiting threads. For example, if our CyclicBarrier limit is 5
and we have 15 threads that call await() , then the CyclicBarrier will be activated a total
of three times.

=== ForkJoinPool

- The Fork/Join framework relies on the concept of recursion to solve complex tasks.

Applying the fork/join framework requires us to perform three steps:

1. Create a `ForkJoinTask` .
2. Create the `ForkJoinPool` .
3. Start the `ForkJoinTask` .

you should know how to implement the fork/join solution by extending one of two classes, `RecursiveAction` and `RecursiveTask` , both of which imple-
ment the `ForkJoinTask` interface.

The first class, `RecursiveAction`, is an abstract class that requires us to implement the `compute()` method, which returns `void` , to perform the bulk of the work. The second class, `RecursiveTask` , is an abstract generic class that requires us to implement the `compute()` method, which returns the generic type, to perform the bulk of the work.

=== RecursiveAction
[source,java]
----
import java.util.*;
import java.util.concurrent.*;

public class WeighAnimalAction extends RecursiveAction {
    private int start;
    private int end;
    private Double[] weights;

    public WeighAnimalAction(Double[] weights, int start, int end) {
        this.start = start;
        this.end = end;
        this.weights = weights;
    }

    protected void compute() {
        if (end-start <= 3) {
            for (int i = start; i < end; i++) {
                weights[i] = (Double) new Random().nextInt();
            }
        } else {
            int middle = start + (end-start) / 2;
            invokeAll(new WeighAnimalAction(weights, start, middle),
                new WeighAnimalAction(weights, middle, end));
        }
    }
}
----

// use it in main method
[source,java]
----
public static void main(String[] args) {
Double[] weights = new Double[10];
ForkJoinTask<?> task = new WeighAnimalAction(weights,0,weights.length);
ForkJoinPool pool pool = new ForkJoinPool();
pool.invoke(task);
// Print results
System.out.println();
System.out.print("Weights: ");
Arrays.asList(weights).stream().forEach(
    d -> System.out.print(d.intValue()+" "));
}
----

WARNING: Creating a ForkJoinTask and submitting it to a ForkJoinPool does not
guarantee it will be executed immediately. For example, a recursive step
may generate 10 tasks when there are only four threads available. Like a
pooled thread executor, the tasks will wait for an available thread to start
processing the data.

The subtasks can be invoked either by invokeAll() or fork() method (use fork() when the subtask returns a value). Use the join() method to get the computed results (if you used fork() method earlier).

=== RecursiveTask<T>
[source,java]
----
public class WeighAnimalTask extends RecursiveTask<Double> {
    private int start;
    private int end;
    private Double[] weights;

    protected Double compute() {
        if (end - start <= 3) {
            double sum = 0;
            for (int i = start; i < end; i++) {
                weights[i] = (Double) new Random().nextInt();
                sum += weights[i];
            }

            return sum;
        } else {
            int middle = start + (end-start) / 2;
            RecursiveTask<Double> otherTask = new WeighAnimalTask(weights, start, middle);
            otherTask.fork(); //start this task in other thread

            return new WeighAnimalTask(weights,middle,end).compute() + otherTask.join();
        } 
    }
}
----

using in main

[source,java]
----
ForkJoinTask<Double> task = new WeighAnimalTask(weights,0,weights.length);
ForkJoinPool pool pool = new ForkJoinPool();
Double sum = pool.invoke(task);
System.out.println("Sum: "+sum);
----

- The `invokeAll()` method takes two instances of fork/join class and do not return a result.

- `fork()` method causes a new task to be submitted to the pool

- `join()` method called after `fork()` and causes current thread to wait for the results of the subtask.

- To get the number of processors configuration in Fork/Join pool

```java
ForkJoinPool.commonPool().getParallelism();
```

- The `getParallelism()` get value from `java.util.concurrent.ForkJoinPool.common.parallelism`, it means you can modify it using `System.setProperty`

```java
import java.util.concurrent.ForkJoinPool;
public class Parallelism {
    public static void main(String []args) {
        System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "8");
        System.out.println(ForkJoinPool.commonPool().getParallelism()); // 8
    }
}
```

- or execute the program using JVM paramemter

```java
java -Djava.util.concurrent.ForkJoinPool.common.parallelism=8 GetParallelism
```

== Deadlock

- Deadlock occurs when two or more threads are blocked forever, each waiting for the other.

== Starvation

- Starvation occurs when a single thread is perpetually deined access to a shared resources or lock.

== Livelock

- Livelock occurs when two or more threads are conceptually blocked forever, although they
are each still active and trying to complete their task. Livelock is a special case of resource
starvation in which two or more threads actively try to acquire a set of locks, are unable to
do so, and restart part of the process.

- Livelock is often a result of two threads trying to resolve a deadlock.

- In practice, livelock is often very difficult issue to detect. Threads in a livelock state appear
active and able to respond to requests, even when they are in fact stuck in an endless cycle.


=== Questions note:

- Only `Callable` capbable of throwing checked exception (not `Runnable`)

- `scheduleWithFixedDelay()` and `scheduleAtFixedRate()` only support `Runnable`

- `sorted()` on a parallel stream does not mean that `findAny()` will return the first record.
`findAny()` will return the value from the first thread that retrieves a record.

- With `RecursiveAction`, `Object result = pool.invoke(action);`` can still compile if the ForkJoinTask is generic `ForkJoinTask<?>`

- The stream that is created by `flatMap()` is not parallel by default, even though its elements are parallel stream.

- Applications with many resource-heavy tasks tend to benefit more from concurrency than ones with CPU-intensive tasks.

- `Future<?>.get` wait for the computed result, if you wrap a try/catch around it, then all exceptions in `call()` are handled.


# Note from other book

- creating thread by extending `Thread`
```java
class MyThread extends Thread {
    @Override
    public void run() {
        try {
            sleep(1000);

        } catch (InterruptedException e) {

        }
    }

    public static void main(String[] args) {
        Thread t = new Thread();
        t.start();
    }
}
```

- creating thread by implementing `Runnable` interface

```java
class RunnableImpl implements Runnable {
    @Override
    public void run() {
        System.out.println("in run() thread name is " + Thread.getCurrentThread().getName());
    }

    public static void main(String[] args) {
        Thread t = new Thread(new RunnableImpl());
        t.start();
        System.out.println("in main() thread name is " + Thread.getCurrentThread().getName());
    }
}
```

- the section of code that is commonly accessed and modified by more than one thread is known as critical section.

- Inside a `synchronized` block, if an exception is thrown, the lock is automatically released by the JVM.

- If `synchronized`, an instance method will implicitly acquire a lock on `this` reference.

- For static method, acquire lock on class object

```java
public synchronized void assign(int i) {
    val = i;
}

// the above code is equivalent with

public void assign(int i) {
    synchronized(this) {
        val = i;
    }
}

// with static method

public static synchronized void assign(int i){}

// is equivalent with

public static void assign(int i){
    synchronized(SomeClass.class) {

    }
}
```

- you cannot declare constructors `synchronized`, it will result in complation error, because JVM ensure that only 1 thread can invoke a constructor call at a given point in time.

- the `lock` is obtained for an object, not for a piece of code, this is a commonly beginner misunderstanding.

## Deadlock

- A deadlock arises when multiple threads are in a situation where they cannot proceed and wait indefinitely for the others to terminate.

## live lock

- Consider two threads t1 and t2. t1 makes change and t2 undoes that change. when both threads t1 and t2 work, it will appear as though lots of work is getting done, but not progress is made.

- Similar to deadlock, the process hang. However, in deadlock, the threads state are never change, in livelock, the state are change continuously. 

## java.util.concurrent.atomic package

```java
AtomicBoolean;
AtomicInteger;
AtomicIntegerArray;
AtomicLong;
AtomicLongArray;
AtomicReference<V>;
AtomicReferenceArray<E>;
```

- The classes such as AtomicInteger do not use a lock; rather, they internally use `volatile` variables and a low-level mechanism known as Compare-and-Set (CAS). For this reason, using `AtomicInteger` and related classes is faster than using lock with `synchronized` keyword.

## java.util.concurrent Collections

- the high-level abstractions for synchronizing activities of two or more threads are known as `synchronizers`. Synchronizer internally makes use of the existing low-level APIs for thread coordination.

- `Semaphore`: counter to control number of threads that can access a resource at the same time

- `CountDownLatch`

- `Exchanger`: exchange data between two threads.

- `CyclicBarrier`

- `Phaser`: coordinate threads by phases.

- For the exam, you only need to know `CyclicBarrier`

```java
CyclicBarrier(int numThreads);
CyclicBarrier(int parties, Runnable barrierAction);
int await();
int await(long timeout, TimeUnit unit);
boolean isBroken();
void reset();
```

Example

```java
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.BrokenBarrierException;

class MixedDoubleTennisGame extends Thread {
    @Override
    public void run() {
        System.out.println("All 4 players are ready, start");
    }
}

class Player extends Thread {
    CyclicBarrier waitPoint;

    public Player(CyclicBarrier barrier, String name) {
        this.setName(name);
        waitPoint = barrier;
        this.start();
    }

    @Override
    public void run() {
        System.out.println("Player " + getName() + " is ready");
        try {
            waitPoint.await();
        } catch (BrokenBarrierException | InterruptedException e) {
            System.out.println("An exception occured while wating");
        }
    }
}

class CyclicBarrierTest {
    public static void main(String[] args) {
        CyclicBarrier cb = new CyclicBarrier(4, new MixedDoubleTennisGame());

        new Player(cb, "P1");
        new Player(cb, "P2");
        new Player(cb, "P3");
        new Player(cb, "P4");
    }
}
```

- ConcurrentModificationException with ArrayList. Because iterators of ArrayList are fail-fast. it will throw exception if it detects that the underlying container has changed when it's iterating over the elements of the container.

```java
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class COWList {
    public static void main(String[] args) {
        List<String> aList = new CopyOnWriteArrayList<>();
        aList.add("one");
        aList.add("two");
        aList.add("three");

        Iterator listIter = aList.iterator();
        
        while (listIter.hasNext()) {
            System.out.println(listIter.next());
            aList.add("four"); // the program does not crash
        }
    }
}
```

output:
```
one
two
three
```

- If you replace `new CopyOnWriteArrayList<>()` with `new ArrayList<>();` a ConcurrentModificationException will occur.

However, you can remove elements while iterating through an `ArrayList`

- Another way to execute Thread via an Excecutor

```java
class Task implements Runnable {
    public void run() {
        System.out.println("Calling Task.run()");
    }
}

class RepeatedExecutor implements Executor {
    @Override
    public void execute(Runnable runnable) {
        new Thread(runnable).start();
    }

    public void execute(Runnable runnable, int times) {
        for (int i = 0; i < 3; i++)
            execute(runnable);
    }
}

class ExecutorTest {
    public static void main(String[] args) {
        Runnable runnable = new Task();
        Thread thread = new Thread(runnable);
        thread.start();
        RepeatedExecutor executor = new RepeatedExecutor();
        executor.execute(runnable, 3);
    }
}
```

- Create a Callable, submit it to ExecutorService

```java
class Factorial implements Callable<Long> {
    long n;
    public Factorial(long n) {
this.n = n; }
    public Long call() throws Exception {
        if(n <= 0) {
            throw new Exception("for finding factorial, N should be > 0");
        }
        long fact = 1;
        for(long longVal = 1; longVal <= n; longVal++) {
            fact *= longVal;
        }
        return fact;
    }
}

class CallableTest {
    public static void main(String []args) throws Exception {
        // the value for which we want to find the factorial
        long N = 20;
        // get a callable task to be submitted to the executor service
        Callable<Long> task = new Factorial(N);
        // create an ExecutorService with a fixed thread pool having one thread
        ExecutorService es = Executors.newSingleThreadExecutor();
        // submit the task to the executor service and store the Future object
        Future<Long> future = es.submit(task);
        // wait for the get() method that blocks until the computation is complete.
        System.out.printf("factorial of %d is %d", N, future.get());
        // done. shutdown the executor service since we don't need it anymore
        es.shutdown();
    } 
}
```

## Parallel Fork/Join framework

- The framework is an implementation of the ExecutorService interface and provides an easy-to-use concurrent platform in order to exploit multiple processors.

- This model is particularly useful for divide-and-conquer problems.

- Dividing the task into smaller tasks is `forking`, and merging the results from the smaller task is `joining`.

- The fork/join framework uses the stealing algorithm: when a worker thread completes its work and is free, it takes (or steal) work from other threads that are still busy doing some work.

pseudocode for fork/join

```
forkJoinAlgorithm() {
    fork the tasks;
    join the tasks;
    compose the results;
}
```

example
```
doRecursiveTask(input) {
    if (the task is small enough to be handle by a thread) {
        compute the small task
        return the result
    } else {
        fork the task into two parts
        call compute() on first task, join() on second task, return combined results.
    }
}
```

## parallel stream

- you can convert a parallel stream to a sequential stream by callling `sequential()`.

```java
List<Integer> ints = Arrays.asList(1, 2, 3, 4, 5);
System.out.println(ints.parallelStream().filter(i -> i % 2 == 0).sequential().isParallel()); // false
```

```java
class CorrectStringSplitAndConcatenate {
    public static void main(String []args) {
        String words[] = "the quick brown fox jumps over the lazy dog".split(" ");
        Optional<String> originalString =
                (Arrays.stream(words).parallel().reduce((a, b) -> a + " " + b));
        System.out.println(originalString.get());
    }
}
```
